/* tslint:disable */
/* eslint-disable */
/**
 * sdk_api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AvatarData
 */
export interface AvatarData {
    /**
     * 
     * @type {string}
     * @memberof AvatarData
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof AvatarData
     */
    'uploadSignedUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AvatarData
     */
    'readSignedUrl': string;
}
/**
 * 
 * @export
 * @interface Bid
 */
export interface Bid {
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'id': string;
    /**
     * 
     * @type {ChainType}
     * @memberof Bid
     */
    'chainType': ChainType;
    /**
     * 
     * @type {NetworkId}
     * @memberof Bid
     */
    'networkId': NetworkId;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'updateAt': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'itemDocumentId': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'bidder': string;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'bidPrice': number;
    /**
     * 
     * @type {CryptoCurrencyRate}
     * @memberof Bid
     */
    'cryptoCurrencyRate': CryptoCurrencyRate;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'transactionAt': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'transactionHash': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChainType = {
    Ethereum: 'ethereum'
} as const;

export type ChainType = typeof ChainType[keyof typeof ChainType];


/**
 * Data required for ContractERC721 or ContractERC721Shop
 * @export
 * @interface ContractDataERC721Shop
 */
export interface ContractDataERC721Shop {
    /**
     * 
     * @type {ChainType}
     * @memberof ContractDataERC721Shop
     */
    'chainType': ChainType;
    /**
     * 
     * @type {NetworkId}
     * @memberof ContractDataERC721Shop
     */
    'networkId': NetworkId;
    /**
     * 
     * @type {string}
     * @memberof ContractDataERC721Shop
     */
    'contractAddress': string;
    /**
     * JSON.stringified
     * @type {string}
     * @memberof ContractDataERC721Shop
     */
    'abi': string;
}
/**
 * Data of ContractERC721
 * @export
 * @interface ContractERC721
 */
export interface ContractERC721 {
    /**
     * 
     * @type {string}
     * @memberof ContractERC721
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContractERC721
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof ContractERC721
     */
    'updateAt': string;
    /**
     * 
     * @type {string}
     * @memberof ContractERC721
     */
    'name': string;
    /**
     * 
     * @type {ChainType}
     * @memberof ContractERC721
     */
    'chainType': ChainType;
    /**
     * 
     * @type {NetworkId}
     * @memberof ContractERC721
     */
    'networkId': NetworkId;
    /**
     * 
     * @type {string}
     * @memberof ContractERC721
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ContractERC721
     */
    'initialDeployBlockNumber': number;
    /**
     * 
     * @type {TokenStandardType}
     * @memberof ContractERC721
     */
    'tokenStandardType': TokenStandardType;
}
/**
 * 
 * @export
 * @interface ContractMethodResource
 */
export interface ContractMethodResource {
    /**
     * 
     * @type {string}
     * @memberof ContractMethodResource
     */
    'contractAddress': string;
    /**
     * 
     * @type {NetworkId}
     * @memberof ContractMethodResource
     */
    'networkId': NetworkId;
    /**
     * 
     * @type {ChainType}
     * @memberof ContractMethodResource
     */
    'chainType': ChainType;
    /**
     * 
     * @type {string}
     * @memberof ContractMethodResource
     */
    'methodName': string;
    /**
     * 
     * @type {string}
     * @memberof ContractMethodResource
     */
    'abi': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof ContractMethodResource
     */
    'args': Array<any>;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateItemStock
 */
export interface CreateOrUpdateItemStock {
    /**
     * 
     * @type {SignatureDomain}
     * @memberof CreateOrUpdateItemStock
     */
    'domain': SignatureDomain;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStock
     */
    'primaryType': string;
    /**
     * 
     * @type {CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage}
     * @memberof CreateOrUpdateItemStock
     */
    'message': CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage;
    /**
     * 
     * @type {object}
     * @memberof CreateOrUpdateItemStock
     */
    'types': object;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateItemStockPhysicalShippingInfo200Response
 */
export interface CreateOrUpdateItemStockPhysicalShippingInfo200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfo200Response
     */
    'data': string;
    /**
     * 
     * @type {object}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfo200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateItemStockPhysicalShippingInfoRequest
 */
export interface CreateOrUpdateItemStockPhysicalShippingInfoRequest {
    /**
     * 
     * @type {CreateOrUpdateItemStock}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequest
     */
    'data': CreateOrUpdateItemStock;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequest
     */
    'signature': string;
}
/**
 * Request body data model for CreateOrUpdateItemStockPhysicalShippingInfo API
 * @export
 * @interface CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
 */
export interface CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'postalCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'address1': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'address2': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'address3': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateItemStockPhysicalShippingInfoRequestBodyMessage
     */
    'requestTimestamp': string;
}
/**
 * 
 * @export
 * @interface CreateStripePaymentIntent200Response
 */
export interface CreateStripePaymentIntent200Response {
    /**
     * Publishable API-Key passed to loadStripe on the client side
     * @type {string}
     * @memberof CreateStripePaymentIntent200Response
     */
    'publishableKey': string;
    /**
     * Stripe\'s PaymentIntent ClientSecret
     * @type {string}
     * @memberof CreateStripePaymentIntent200Response
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface CreateStripePaymentIntentRequest
 */
export interface CreateStripePaymentIntentRequest {
    /**
     * Item id that will be purchased
     * @type {string}
     * @memberof CreateStripePaymentIntentRequest
     */
    'itemId': string;
    /**
     * Buyer wallet address
     * @type {string}
     * @memberof CreateStripePaymentIntentRequest
     */
    'toAddress': string;
    /**
     * 
     * @type {UserResidence}
     * @memberof CreateStripePaymentIntentRequest
     */
    'userResidence': UserResidence;
}
/**
 * Currency type used in Stripe
 * @export
 * @enum {string}
 */

export const CreditCardStripeCurrencyType = {
    Jpy: 'jpy',
    Usd: 'usd',
    Eur: 'eur'
} as const;

export type CreditCardStripeCurrencyType = typeof CreditCardStripeCurrencyType[keyof typeof CreditCardStripeCurrencyType];


/**
 * 
 * @export
 * @interface CryptoCurrencyRate
 */
export interface CryptoCurrencyRate {
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrencyRate
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrencyRate
     */
    'updateAt': string;
    /**
     * 
     * @type {CryptoCurrencyType}
     * @memberof CryptoCurrencyRate
     */
    'currency': CryptoCurrencyType;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrencyRate
     */
    'jpy': number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrencyRate
     */
    'eur': number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrencyRate
     */
    'usd': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CryptoCurrencyType = {
    Eth: 'eth',
    Matic: 'matic'
} as const;

export type CryptoCurrencyType = typeof CryptoCurrencyType[keyof typeof CryptoCurrencyType];


/**
 * 
 * @export
 * @interface DomainAndPrimaryTypeAndMessage
 */
export interface DomainAndPrimaryTypeAndMessage {
    /**
     * 
     * @type {SignatureDomain}
     * @memberof DomainAndPrimaryTypeAndMessage
     */
    'domain': SignatureDomain;
    /**
     * 
     * @type {string}
     * @memberof DomainAndPrimaryTypeAndMessage
     */
    'primaryType': string;
    /**
     * 
     * @type {MessageObject}
     * @memberof DomainAndPrimaryTypeAndMessage
     */
    'message': MessageObject;
    /**
     * 
     * @type {object}
     * @memberof DomainAndPrimaryTypeAndMessage
     */
    'types': object;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAvatar200Response
 */
export interface GetAvatar200Response {
    /**
     * 
     * @type {object}
     * @memberof GetAvatar200Response
     */
    'meta'?: object;
    /**
     * 
     * @type {AvatarData}
     * @memberof GetAvatar200Response
     */
    'data'?: AvatarData;
}
/**
 * 
 * @export
 * @interface GetBiddedItemStocksByWalletAddress200Response
 */
export interface GetBiddedItemStocksByWalletAddress200Response {
    /**
     * 
     * @type {Array<ItemStock>}
     * @memberof GetBiddedItemStocksByWalletAddress200Response
     */
    'data': Array<ItemStock>;
    /**
     * 
     * @type {object}
     * @memberof GetBiddedItemStocksByWalletAddress200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetBoughtItemStocksByWalletAddress200Response
 */
export interface GetBoughtItemStocksByWalletAddress200Response {
    /**
     * 
     * @type {ItemStocksData}
     * @memberof GetBoughtItemStocksByWalletAddress200Response
     */
    'data': ItemStocksData;
    /**
     * 
     * @type {object}
     * @memberof GetBoughtItemStocksByWalletAddress200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetContractERC721ById200Response
 */
export interface GetContractERC721ById200Response {
    /**
     * 
     * @type {ContractERC721}
     * @memberof GetContractERC721ById200Response
     */
    'data': ContractERC721;
    /**
     * 
     * @type {object}
     * @memberof GetContractERC721ById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItemById200Response
 */
export interface GetItemById200Response {
    /**
     * 
     * @type {Item}
     * @memberof GetItemById200Response
     */
    'data': Item;
    /**
     * 
     * @type {object}
     * @memberof GetItemById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItemByTokenERC721200Response
 */
export interface GetItemByTokenERC721200Response {
    /**
     * 
     * @type {Item}
     * @memberof GetItemByTokenERC721200Response
     */
    'data': Item;
    /**
     * 
     * @type {object}
     * @memberof GetItemByTokenERC721200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItemStockById200Response
 */
export interface GetItemStockById200Response {
    /**
     * 
     * @type {ItemStock}
     * @memberof GetItemStockById200Response
     */
    'data': ItemStock;
    /**
     * 
     * @type {object}
     * @memberof GetItemStockById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItemStockPhysicalShippingInfoByItemStockId200Response
 */
export interface GetItemStockPhysicalShippingInfoByItemStockId200Response {
    /**
     * 
     * @type {ItemStockPhysicalShippingInfo}
     * @memberof GetItemStockPhysicalShippingInfoByItemStockId200Response
     */
    'data': ItemStockPhysicalShippingInfo;
    /**
     * 
     * @type {object}
     * @memberof GetItemStockPhysicalShippingInfoByItemStockId200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItemStockPhysicalShippingInfoByItemStockIdRequest
 */
export interface GetItemStockPhysicalShippingInfoByItemStockIdRequest {
    /**
     * 
     * @type {DomainAndPrimaryTypeAndMessage}
     * @memberof GetItemStockPhysicalShippingInfoByItemStockIdRequest
     */
    'data': DomainAndPrimaryTypeAndMessage;
    /**
     * 
     * @type {string}
     * @memberof GetItemStockPhysicalShippingInfoByItemStockIdRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface GetItemStockPhysicalShippingInfoStatusByItemStockId200Response
 */
export interface GetItemStockPhysicalShippingInfoStatusByItemStockId200Response {
    /**
     * 
     * @type {ItemStockPhysicalShippingInfoStatus}
     * @memberof GetItemStockPhysicalShippingInfoStatusByItemStockId200Response
     */
    'data': ItemStockPhysicalShippingInfoStatus;
    /**
     * 
     * @type {object}
     * @memberof GetItemStockPhysicalShippingInfoStatusByItemStockId200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetItems200Response
 */
export interface GetItems200Response {
    /**
     * 
     * @type {Array<Item>}
     * @memberof GetItems200Response
     */
    'data': Array<Item>;
    /**
     * 
     * @type {object}
     * @memberof GetItems200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetPaymentIntentById200Response
 */
export interface GetPaymentIntentById200Response {
    /**
     * 
     * @type {GetPaymentIntentByIdResponseBodyData}
     * @memberof GetPaymentIntentById200Response
     */
    'data': GetPaymentIntentByIdResponseBodyData;
    /**
     * 
     * @type {object}
     * @memberof GetPaymentIntentById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetPaymentIntentByIdResponseBodyData
 */
export interface GetPaymentIntentByIdResponseBodyData {
    /**
     * 
     * @type {string}
     * @memberof GetPaymentIntentByIdResponseBodyData
     */
    'cryptoPaymentIntentId': string;
    /**
     * 
     * @type {ContractMethodResource}
     * @memberof GetPaymentIntentByIdResponseBodyData
     */
    'contractMethodResource': ContractMethodResource;
}
/**
 * 
 * @export
 * @interface GetProductERC721ById200Response
 */
export interface GetProductERC721ById200Response {
    /**
     * 
     * @type {ProductERC721}
     * @memberof GetProductERC721ById200Response
     */
    'data': ProductERC721;
    /**
     * 
     * @type {object}
     * @memberof GetProductERC721ById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetProfile200Response
 */
export interface GetProfile200Response {
    /**
     * 
     * @type {ProfileData}
     * @memberof GetProfile200Response
     */
    'data': ProfileData | null;
    /**
     * 
     * @type {object}
     * @memberof GetProfile200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetSellableItemStockERC721Id200Response
 */
export interface GetSellableItemStockERC721Id200Response {
    /**
     * 
     * @type {SellableItemStockERC721IdData}
     * @memberof GetSellableItemStockERC721Id200Response
     */
    'data': SellableItemStockERC721IdData;
    /**
     * 
     * @type {object}
     * @memberof GetSellableItemStockERC721Id200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetSignByItemStockId200Response
 */
export interface GetSignByItemStockId200Response {
    /**
     * 
     * @type {SignData}
     * @memberof GetSignByItemStockId200Response
     */
    'data': SignData;
    /**
     * 
     * @type {object}
     * @memberof GetSignByItemStockId200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetTokenERC721ById200Response
 */
export interface GetTokenERC721ById200Response {
    /**
     * 
     * @type {TokenERC721}
     * @memberof GetTokenERC721ById200Response
     */
    'data': TokenERC721;
    /**
     * 
     * @type {object}
     * @memberof GetTokenERC721ById200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetTokenERC721sByContractAddress200Response
 */
export interface GetTokenERC721sByContractAddress200Response {
    /**
     * 
     * @type {Array<TokenERC721>}
     * @memberof GetTokenERC721sByContractAddress200Response
     */
    'data': Array<TokenERC721>;
    /**
     * 
     * @type {object}
     * @memberof GetTokenERC721sByContractAddress200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetTokenERC721sByWalletAddress200Response
 */
export interface GetTokenERC721sByWalletAddress200Response {
    /**
     * 
     * @type {Array<TokenERC721>}
     * @memberof GetTokenERC721sByWalletAddress200Response
     */
    'data': Array<TokenERC721>;
    /**
     * 
     * @type {object}
     * @memberof GetTokenERC721sByWalletAddress200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface GetTokentERC721sByWalletAddressFromAnyContract200Response
 */
export interface GetTokentERC721sByWalletAddressFromAnyContract200Response {
    /**
     * 
     * @type {Array<TokenERC721>}
     * @memberof GetTokentERC721sByWalletAddressFromAnyContract200Response
     */
    'data': Array<TokenERC721>;
    /**
     * 
     * @type {object}
     * @memberof GetTokentERC721sByWalletAddressFromAnyContract200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface HasNft200Response
 */
export interface HasNft200Response {
    /**
     * 
     * @type {boolean}
     * @memberof HasNft200Response
     */
    'data': boolean;
    /**
     * 
     * @type {object}
     * @memberof HasNft200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface HasNfts200Response
 */
export interface HasNfts200Response {
    /**
     * 
     * @type {boolean}
     * @memberof HasNfts200Response
     */
    'data': boolean;
    /**
     * 
     * @type {object}
     * @memberof HasNfts200Response
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'updateAt': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'description': string;
    /**
     * URL for item preview
     * @type {Array<PreviewMedia>}
     * @memberof Item
     */
    'previews': Array<PreviewMedia>;
    /**
     * 
     * @type {ItemType}
     * @memberof Item
     */
    'type': ItemType;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'startAt': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'endAt': string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'price': number;
    /**
     * 
     * @type {CryptoCurrencyRate}
     * @memberof Item
     */
    'cryptoCurrencyRate': CryptoCurrencyRate;
    /**
     * Transaction fees paid to Mint
     * @type {number}
     * @memberof Item
     */
    'feeRatePermill': number;
    /**
     * Any Tag
     * @type {Array<string>}
     * @memberof Item
     */
    'tags': Array<string>;
    /**
     * 
     * @type {PaymentMethodData}
     * @memberof Item
     */
    'paymentMethodData': PaymentMethodData;
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'itemStockIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'availableStockNum': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'productERC721Ids': Array<string>;
    /**
     * An empty array is entered except for auction items
     * @type {Array<Bid>}
     * @memberof Item
     */
    'bids': Array<Bid>;
    /**
     * 
     * @type {object}
     * @memberof Item
     */
    'metadata': object | null;
}
/**
 * 
 * @export
 * @interface ItemPaymentMethodDataCreditCardStripeFixedPrice
 */
export interface ItemPaymentMethodDataCreditCardStripeFixedPrice {
    /**
     * 
     * @type {string}
     * @memberof ItemPaymentMethodDataCreditCardStripeFixedPrice
     */
    'paymentMethod': ItemPaymentMethodDataCreditCardStripeFixedPricePaymentMethodEnum;
    /**
     * 
     * @type {CreditCardStripeCurrencyType}
     * @memberof ItemPaymentMethodDataCreditCardStripeFixedPrice
     */
    'currency': CreditCardStripeCurrencyType;
}

export const ItemPaymentMethodDataCreditCardStripeFixedPricePaymentMethodEnum = {
    CreditCardStripeFixedPrice: 'credit-card-stripe-fixed-price'
} as const;

export type ItemPaymentMethodDataCreditCardStripeFixedPricePaymentMethodEnum = typeof ItemPaymentMethodDataCreditCardStripeFixedPricePaymentMethodEnum[keyof typeof ItemPaymentMethodDataCreditCardStripeFixedPricePaymentMethodEnum];

/**
 * 
 * @export
 * @interface ItemPaymentMethodDataEthereumContractERC721ShopAuction
 */
export interface ItemPaymentMethodDataEthereumContractERC721ShopAuction {
    /**
     * 
     * @type {string}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopAuction
     */
    'paymentMethod': ItemPaymentMethodDataEthereumContractERC721ShopAuctionPaymentMethodEnum;
    /**
     * 
     * @type {ContractDataERC721Shop}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopAuction
     */
    'contractDataERC721Shop': ContractDataERC721Shop;
    /**
     * 
     * @type {number}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopAuction
     */
    'minBidPercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopAuction
     */
    'defaultEndAt': string;
}

export const ItemPaymentMethodDataEthereumContractERC721ShopAuctionPaymentMethodEnum = {
    EthereumContractErc721ShopAuction: 'ethereum-contract-erc721-shop-auction'
} as const;

export type ItemPaymentMethodDataEthereumContractERC721ShopAuctionPaymentMethodEnum = typeof ItemPaymentMethodDataEthereumContractERC721ShopAuctionPaymentMethodEnum[keyof typeof ItemPaymentMethodDataEthereumContractERC721ShopAuctionPaymentMethodEnum];

/**
 * 
 * @export
 * @interface ItemPaymentMethodDataEthereumContractERC721ShopFixedPrice
 */
export interface ItemPaymentMethodDataEthereumContractERC721ShopFixedPrice {
    /**
     * 
     * @type {string}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopFixedPrice
     */
    'paymentMethod': ItemPaymentMethodDataEthereumContractERC721ShopFixedPricePaymentMethodEnum;
    /**
     * 
     * @type {ContractDataERC721Shop}
     * @memberof ItemPaymentMethodDataEthereumContractERC721ShopFixedPrice
     */
    'contractDataERC721Shop': ContractDataERC721Shop;
}

export const ItemPaymentMethodDataEthereumContractERC721ShopFixedPricePaymentMethodEnum = {
    EthereumContractErc721ShopFixedPrice: 'ethereum-contract-erc721-shop-fixed-price'
} as const;

export type ItemPaymentMethodDataEthereumContractERC721ShopFixedPricePaymentMethodEnum = typeof ItemPaymentMethodDataEthereumContractERC721ShopFixedPricePaymentMethodEnum[keyof typeof ItemPaymentMethodDataEthereumContractERC721ShopFixedPricePaymentMethodEnum];

/**
 * 
 * @export
 * @interface ItemStock
 */
export interface ItemStock {
    /**
     * 
     * @type {string}
     * @memberof ItemStock
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStock
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStock
     */
    'updateAt': string;
    /**
     * 
     * @type {ItemStockStatus}
     * @memberof ItemStock
     */
    'status': ItemStockStatus;
    /**
     * 
     * @type {Array<ProductERC721>}
     * @memberof ItemStock
     */
    'productsData': Array<ProductERC721>;
    /**
     * 
     * @type {Item}
     * @memberof ItemStock
     */
    'item': Item;
}
/**
 * ItemStockPhysicalShippingInfo data model
 * @export
 * @interface ItemStockPhysicalShippingInfo
 */
export interface ItemStockPhysicalShippingInfo {
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'postalCode': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'address1': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'address2': string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'address3': string | null;
    /**
     * 
     * @type {ItemStockPhysicalShippingInfoStatus}
     * @memberof ItemStockPhysicalShippingInfo
     */
    'status': ItemStockPhysicalShippingInfoStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ItemStockPhysicalShippingInfoStatus = {
    ShippingAddressNotRegistered: 'shipping-address-not-registered',
    ShippingAddressRegistered: 'shipping-address-registered',
    Shipped: 'shipped'
} as const;

export type ItemStockPhysicalShippingInfoStatus = typeof ItemStockPhysicalShippingInfoStatus[keyof typeof ItemStockPhysicalShippingInfoStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ItemStockStatus = {
    Created: 'created',
    Minted: 'minted'
} as const;

export type ItemStockStatus = typeof ItemStockStatus[keyof typeof ItemStockStatus];


/**
 * 
 * @export
 * @interface ItemStocksData
 */
export interface ItemStocksData {
    /**
     * 
     * @type {Array<ItemStocksDataItemStocksInner>}
     * @memberof ItemStocksData
     */
    'itemStocks': Array<ItemStocksDataItemStocksInner>;
}
/**
 * 
 * @export
 * @interface ItemStocksDataItemStocksInner
 */
export interface ItemStocksDataItemStocksInner {
    /**
     * 
     * @type {string}
     * @memberof ItemStocksDataItemStocksInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStocksDataItemStocksInner
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof ItemStocksDataItemStocksInner
     */
    'updateAt': string;
    /**
     * 
     * @type {ItemStockStatus}
     * @memberof ItemStocksDataItemStocksInner
     */
    'status': ItemStockStatus;
    /**
     * 
     * @type {Array<ProductERC721>}
     * @memberof ItemStocksDataItemStocksInner
     */
    'productsData': Array<ProductERC721>;
    /**
     * 
     * @type {Item}
     * @memberof ItemStocksDataItemStocksInner
     */
    'item': Item;
    /**
     * 
     * @type {ItemStockPhysicalShippingInfoStatus}
     * @memberof ItemStocksDataItemStocksInner
     */
    'physicalShippingInfoStatus': ItemStockPhysicalShippingInfoStatus;
}
/**
 * 
 * @export
 * @interface ItemStocksDataItemStocksInnerAllOf
 */
export interface ItemStocksDataItemStocksInnerAllOf {
    /**
     * 
     * @type {ItemStockPhysicalShippingInfoStatus}
     * @memberof ItemStocksDataItemStocksInnerAllOf
     */
    'physicalShippingInfoStatus': ItemStockPhysicalShippingInfoStatus;
}
/**
 * Item Type
 * @export
 * @enum {string}
 */

export const ItemType = {
    Normal: 'normal',
    WithPhysicalItem: 'with-physical-item'
} as const;

export type ItemType = typeof ItemType[keyof typeof ItemType];


/**
 * 
 * @export
 * @interface MessageObject
 */
export interface MessageObject {
    /**
     * 
     * @type {string}
     * @memberof MessageObject
     */
    'walletAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageObject
     */
    'requestTimestamp'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NetworkId = {
    NUMBER_1: 1,
    NUMBER_4: 4,
    NUMBER_80001: 80001,
    NUMBER_137: 137,
    NUMBER_31337: 31337
} as const;

export type NetworkId = typeof NetworkId[keyof typeof NetworkId];


/**
 * @type PaymentMethodData
 * Data that differs depending on the paymentMethod
 * @export
 */
export type PaymentMethodData = ItemPaymentMethodDataCreditCardStripeFixedPrice | ItemPaymentMethodDataEthereumContractERC721ShopAuction | ItemPaymentMethodDataEthereumContractERC721ShopFixedPrice;

/**
 * Preview Media
 * @export
 * @interface PreviewMedia
 */
export interface PreviewMedia {
    /**
     * 
     * @type {string}
     * @memberof PreviewMedia
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof PreviewMedia
     */
    'mimeType': string;
}
/**
 * 
 * @export
 * @interface ProductERC721
 */
export interface ProductERC721 {
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'updateAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'status': ProductERC721StatusEnum;
    /**
     * 
     * @type {TokenStandardType}
     * @memberof ProductERC721
     */
    'tokenStandardType': TokenStandardType;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'contractERC721Id': string;
    /**
     * 
     * @type {number}
     * @memberof ProductERC721
     */
    'tokenId': number;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'tokenURI': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'creatorAddress': string;
    /**
     * 
     * @type {object}
     * @memberof ProductERC721
     */
    'metadata': object | null;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'itemStockDocumentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'productBlueprintId': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductERC721
     */
    'productGroupId': string | null;
}

export const ProductERC721StatusEnum = {
    Created: 'created',
    PackedInItem: 'packed-in-item',
    TxProgressing: 'tx-progressing',
    Minted: 'minted',
    Archived: 'archived'
} as const;

export type ProductERC721StatusEnum = typeof ProductERC721StatusEnum[keyof typeof ProductERC721StatusEnum];

/**
 * 
 * @export
 * @interface ProfileData
 */
export interface ProfileData {
    /**
     * 
     * @type {WalletAddressProfile}
     * @memberof ProfileData
     */
    'profile': WalletAddressProfile;
    /**
     * 
     * @type {string}
     * @memberof ProfileData
     */
    'avatarImageUrl': string;
}
/**
 * 
 * @export
 * @interface SellableItemStockERC721IdData
 */
export interface SellableItemStockERC721IdData {
    /**
     * 
     * @type {string}
     * @memberof SellableItemStockERC721IdData
     */
    'itemStockId': string;
}
/**
 * 
 * @export
 * @interface SignData
 */
export interface SignData {
    /**
     * 
     * @type {string}
     * @memberof SignData
     */
    'signature': string;
    /**
     * Arguments of the corresponding contract method
     * @type {Array<any>}
     * @memberof SignData
     */
    'contractMethodArg': Array<any>;
}
/**
 * 
 * @export
 * @interface SignatureDomain
 */
export interface SignatureDomain {
    /**
     * 
     * @type {string}
     * @memberof SignatureDomain
     */
    'chainId': string;
    /**
     * 
     * @type {string}
     * @memberof SignatureDomain
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignatureDomain
     */
    'version': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SignatureType = {
    FixedPrice: 'ethereum-contract-erc721-shop-fixed-price',
    AuctionBid: 'ethereum-contract-erc721-shop-auction-bid',
    AuctionWithdraw: 'ethereum-contract-erc721-shop-auction-withdraw'
} as const;

export type SignatureType = typeof SignatureType[keyof typeof SignatureType];


/**
 * 
 * @export
 * @interface TokenERC721
 */
export interface TokenERC721 {
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'createAt': string;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'updateAt': string;
    /**
     * 
     * @type {TokenStandardType}
     * @memberof TokenERC721
     */
    'tokenStandardType': TokenStandardType;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'contractERC721Id': string;
    /**
     * 
     * @type {number}
     * @memberof TokenERC721
     */
    'tokenId': number;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'tokenURI': string;
    /**
     * 
     * @type {object}
     * @memberof TokenERC721
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'mintTransactionHash': string;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'initialOwnerAddress': string;
    /**
     * 
     * @type {string}
     * @memberof TokenERC721
     */
    'currentOwnerAddress': string;
    /**
     * 
     * @type {Array<TransferData>}
     * @memberof TokenERC721
     */
    'transferHistory': Array<TransferData>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TokenStandardType = {
    Erc721: 'ERC721'
} as const;

export type TokenStandardType = typeof TokenStandardType[keyof typeof TokenStandardType];


/**
 * 
 * @export
 * @interface TransferData
 */
export interface TransferData {
    /**
     * 
     * @type {string}
     * @memberof TransferData
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof TransferData
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof TransferData
     */
    'transactionHash': string;
}
/**
 * 
 * @export
 * @interface UpdateProfile200Response
 */
export interface UpdateProfile200Response {
    /**
     * 
     * @type {UpdateProfileData}
     * @memberof UpdateProfile200Response
     */
    'data'?: UpdateProfileData;
    /**
     * 
     * @type {object}
     * @memberof UpdateProfile200Response
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface UpdateProfileData
 */
export interface UpdateProfileData {
    /**
     * 
     * @type {WalletAddressProfile}
     * @memberof UpdateProfileData
     */
    'profile'?: WalletAddressProfile;
}
/**
 * 
 * @export
 * @interface UpdateProfileRequest
 */
export interface UpdateProfileRequest {
    /**
     * 
     * @type {WalletAddressProfile}
     * @memberof UpdateProfileRequest
     */
    'profile': WalletAddressProfile;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserResidence = {
    Jp: 'jp',
    Unknown: 'unknown'
} as const;

export type UserResidence = typeof UserResidence[keyof typeof UserResidence];


/**
 * 
 * @export
 * @interface WalletAddressProfile
 */
export interface WalletAddressProfile {
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'walletAddress': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'avatarImageId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'twitterAccountName': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'instagramAccountName': string;
    /**
     * 
     * @type {string}
     * @memberof WalletAddressProfile
     */
    'homepageUrl': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API for creating or updating item stock physical shipping info for given item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {CreateOrUpdateItemStockPhysicalShippingInfoRequest} [createOrUpdateItemStockPhysicalShippingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateItemStockPhysicalShippingInfo: async (mintAccessToken: string, itemStockId: string, createOrUpdateItemStockPhysicalShippingInfoRequest?: CreateOrUpdateItemStockPhysicalShippingInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('createOrUpdateItemStockPhysicalShippingInfo', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemStockId' is not null or undefined
            assertParamExists('createOrUpdateItemStockPhysicalShippingInfo', 'itemStockId', itemStockId)
            const localVarPath = `/sdk_v4/itemStockPhysicalShippingInfos/createOrUpdateItemStockPhysicalShippingInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStockId !== undefined) {
                localVarQueryParameter['itemStockId'] = itemStockId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateItemStockPhysicalShippingInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a PyamentIntent to purchase a given item with a credit card (Stripe) and return the corresponding Secret
         * @param {string} mintAccessToken 
         * @param {CreateStripePaymentIntentRequest} [createStripePaymentIntentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripePaymentIntent: async (mintAccessToken: string, createStripePaymentIntentRequest?: CreateStripePaymentIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('createStripePaymentIntent', 'mintAccessToken', mintAccessToken)
            const localVarPath = `/sdk_v4/stripePayment/createStripePaymentIntent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStripePaymentIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get signed URL for avatar image
         * @param {string} mintAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar: async (mintAccessToken: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getAvatar', 'mintAccessToken', mintAccessToken)
            const localVarPath = `/sdk_v4/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bidded ItemStocks By WalletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {string} [onlyBeforeEnd] 
         * @param {'price' | 'endAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBiddedItemStocksByWalletAddress: async (mintAccessToken: string, walletAddress: string, page: string, perPage: string, onlyBeforeEnd?: string, sortBy?: 'price' | 'endAt', sortDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getBiddedItemStocksByWalletAddress', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('getBiddedItemStocksByWalletAddress', 'walletAddress', walletAddress)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getBiddedItemStocksByWalletAddress', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getBiddedItemStocksByWalletAddress', 'perPage', perPage)
            const localVarPath = `/sdk_v4/itemStocks/getBiddedItemStocksByWalletAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (onlyBeforeEnd !== undefined) {
                localVarQueryParameter['onlyBeforeEnd'] = onlyBeforeEnd;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ItemStock purchased or sold at the specified walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'price' | 'createAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoughtItemStocksByWalletAddress: async (mintAccessToken: string, walletAddress: string, page: string, perPage: string, sortBy?: 'price' | 'createAt', sortDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getBoughtItemStocksByWalletAddress', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('getBoughtItemStocksByWalletAddress', 'walletAddress', walletAddress)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getBoughtItemStocksByWalletAddress', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getBoughtItemStocksByWalletAddress', 'perPage', perPage)
            const localVarPath = `/sdk_v4/itemStocks/getBoughtItemStocksByWalletAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ContractERC721 by  contracId
         * @param {string} mintAccessToken 
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractERC721ById: async (mintAccessToken: string, contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getContractERC721ById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractERC721ById', 'contractId', contractId)
            const localVarPath = `/sdk_v4/contracts/getContractERC721ById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractId !== undefined) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Item of project by specifying Id
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemById: async (mintAccessToken: string, itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItemById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItemById', 'itemId', itemId)
            const localVarPath = `/sdk_v4/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get item by tokenERC721 id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByTokenERC721: async (mintAccessToken: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItemByTokenERC721', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getItemByTokenERC721', 'tokenId', tokenId)
            const localVarPath = `/sdk_v4/items/getItemByTokenERC721`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = tokenId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get ItemStock by Id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockById: async (mintAccessToken: string, itemStockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItemStockById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemStockId' is not null or undefined
            assertParamExists('getItemStockById', 'itemStockId', itemStockId)
            const localVarPath = `/sdk_v4/itemStocks/getById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStockId !== undefined) {
                localVarQueryParameter['itemStockId'] = itemStockId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {GetItemStockPhysicalShippingInfoByItemStockIdRequest} [getItemStockPhysicalShippingInfoByItemStockIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockPhysicalShippingInfoByItemStockId: async (mintAccessToken: string, itemStockId: string, getItemStockPhysicalShippingInfoByItemStockIdRequest?: GetItemStockPhysicalShippingInfoByItemStockIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItemStockPhysicalShippingInfoByItemStockId', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemStockId' is not null or undefined
            assertParamExists('getItemStockPhysicalShippingInfoByItemStockId', 'itemStockId', itemStockId)
            const localVarPath = `/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoByItemStockId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStockId !== undefined) {
                localVarQueryParameter['itemStockId'] = itemStockId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getItemStockPhysicalShippingInfoByItemStockIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info status by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockPhysicalShippingInfoStatusByItemStockId: async (mintAccessToken: string, itemStockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItemStockPhysicalShippingInfoStatusByItemStockId', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemStockId' is not null or undefined
            assertParamExists('getItemStockPhysicalShippingInfoStatusByItemStockId', 'itemStockId', itemStockId)
            const localVarPath = `/sdk_v4/itemStockPhysicalShippingInfos/getItemStockPhysicalShippingInfoStatusByItemStockId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStockId !== undefined) {
                localVarQueryParameter['itemStockId'] = itemStockId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the items of the project
         * @param {string} mintAccessToken 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'beforeStart' | 'beforeEnd' | 'afterEnd'} [saleStatus] 
         * @param {'true' | 'false'} [onlyAvailableStock] 
         * @param {'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price'} [paymentMethod] 
         * @param {string} [tags] Specified by the delimiter of \&#39;,\&#39;
         * @param {'price'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (mintAccessToken: string, page: string, perPage: string, saleStatus?: 'beforeStart' | 'beforeEnd' | 'afterEnd', onlyAvailableStock?: 'true' | 'false', paymentMethod?: 'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price', tags?: string, sortBy?: 'price', sortDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getItems', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getItems', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getItems', 'perPage', perPage)
            const localVarPath = `/sdk_v4/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (saleStatus !== undefined) {
                localVarQueryParameter['saleStatus'] = saleStatus;
            }

            if (onlyAvailableStock !== undefined) {
                localVarQueryParameter['onlyAvailableStock'] = onlyAvailableStock;
            }

            if (paymentMethod !== undefined) {
                localVarQueryParameter['paymentMethod'] = paymentMethod;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This API is responsible to get payment intent by its id
         * @param {string} mintAccessToken 
         * @param {string} paymentIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntentById: async (mintAccessToken: string, paymentIntentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getPaymentIntentById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'paymentIntentId' is not null or undefined
            assertParamExists('getPaymentIntentById', 'paymentIntentId', paymentIntentId)
            const localVarPath = `/sdk_v4/paymentIntents/{paymentIntentId}`
                .replace(`{${"paymentIntentId"}}`, encodeURIComponent(String(paymentIntentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ProductERC721 which is packed in Item and the status of Item is publish
         * @param {string} mintAccessToken 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductERC721ById: async (mintAccessToken: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getProductERC721ById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductERC721ById', 'id', id)
            const localVarPath = `/sdk_v4/products/getProductERC721ById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there is no profile, null will be in the value of data
         * @summary Get the profile associated with the wallet
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (mintAccessToken: string, walletAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getProfile', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('getProfile', 'walletAddress', walletAddress)
            const localVarPath = `/sdk_v4/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sellable (not yet sold) `ItemStockId` for a`Item` to sell on a Smart Contract
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellableItemStockERC721Id: async (mintAccessToken: string, itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getSellableItemStockERC721Id', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSellableItemStockERC721Id', 'itemId', itemId)
            const localVarPath = `/sdk_v4/items/getSellableItemStockERC721Id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Sign required to operate the Smart Contract for Item purchase
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {SignatureType} signatureType 
         * @param {string} [walletAddress] Required only at the time of purchase
         * @param {'jp' | 'unknown'} [residence] Required only at the time of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignByItemStockId: async (mintAccessToken: string, itemStockId: string, signatureType: SignatureType, walletAddress?: string, residence?: 'jp' | 'unknown', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getSignByItemStockId', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'itemStockId' is not null or undefined
            assertParamExists('getSignByItemStockId', 'itemStockId', itemStockId)
            // verify required parameter 'signatureType' is not null or undefined
            assertParamExists('getSignByItemStockId', 'signatureType', signatureType)
            const localVarPath = `/sdk_v4/itemStocks/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStockId !== undefined) {
                localVarQueryParameter['itemStockId'] = itemStockId;
            }

            if (signatureType !== undefined) {
                localVarQueryParameter['signatureType'] = signatureType;
            }

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (residence !== undefined) {
                localVarQueryParameter['residence'] = residence;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get TokenERC721 by Id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721ById: async (mintAccessToken: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getTokenERC721ById', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getTokenERC721ById', 'tokenId', tokenId)
            const localVarPath = `/sdk_v4/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TokenERC721 associated with contractAddress
         * @param {string} mintAccessToken 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721sByContractAddress: async (mintAccessToken: string, contractAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getTokenERC721sByContractAddress', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getTokenERC721sByContractAddress', 'contractAddress', contractAddress)
            const localVarPath = `/sdk_v4/tokens/getTokenERC721sByContractAddress/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TokenERC721 associated with walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721sByWalletAddress: async (mintAccessToken: string, walletAddress: string, page: string, perPage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getTokenERC721sByWalletAddress', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('getTokenERC721sByWalletAddress', 'walletAddress', walletAddress)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getTokenERC721sByWalletAddress', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getTokenERC721sByWalletAddress', 'perPage', perPage)
            const localVarPath = `/sdk_v4/tokens/getTokenERC721sByWalletAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get TokenERC721s by specifying wallet address and contract address
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokentERC721sByWalletAddressFromAnyContract: async (mintAccessToken: string, walletAddress: string, contractAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('getTokentERC721sByWalletAddressFromAnyContract', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('getTokentERC721sByWalletAddressFromAnyContract', 'walletAddress', walletAddress)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getTokentERC721sByWalletAddressFromAnyContract', 'contractAddress', contractAddress)
            const localVarPath = `/sdk_v4/tokens/getTokentERC721sByWalletAddressFromAnyContract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (contractAddress !== undefined) {
                localVarQueryParameter['contractAddress'] = contractAddress;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary has token id of nft or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasNft: async (mintAccessToken: string, walletAddress: string, contractAddress: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('hasNft', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('hasNft', 'walletAddress', walletAddress)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('hasNft', 'contractAddress', contractAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('hasNft', 'tokenId', tokenId)
            const localVarPath = `/sdk_v4/tokens/hasNft`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (contractAddress !== undefined) {
                localVarQueryParameter['contractAddress'] = contractAddress;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = tokenId;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary has nfts or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasNfts: async (mintAccessToken: string, walletAddress: string, contractAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('hasNfts', 'mintAccessToken', mintAccessToken)
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('hasNfts', 'walletAddress', walletAddress)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('hasNfts', 'contractAddress', contractAddress)
            const localVarPath = `/sdk_v4/tokens/hasNfts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (walletAddress !== undefined) {
                localVarQueryParameter['walletAddress'] = walletAddress;
            }

            if (contractAddress !== undefined) {
                localVarQueryParameter['contractAddress'] = contractAddress;
            }

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a profile associated with your wallet
         * @param {string} mintAccessToken 
         * @param {UpdateProfileRequest} [updateProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (mintAccessToken: string, updateProfileRequest?: UpdateProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintAccessToken' is not null or undefined
            assertParamExists('updateProfile', 'mintAccessToken', mintAccessToken)
            const localVarPath = `/sdk_v4/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mintAccessToken !== undefined && mintAccessToken !== null) {
                localVarHeaderParameter['mint-access-token'] = String(mintAccessToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary API for creating or updating item stock physical shipping info for given item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {CreateOrUpdateItemStockPhysicalShippingInfoRequest} [createOrUpdateItemStockPhysicalShippingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken: string, itemStockId: string, createOrUpdateItemStockPhysicalShippingInfoRequest?: CreateOrUpdateItemStockPhysicalShippingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateItemStockPhysicalShippingInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken, itemStockId, createOrUpdateItemStockPhysicalShippingInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a PyamentIntent to purchase a given item with a credit card (Stripe) and return the corresponding Secret
         * @param {string} mintAccessToken 
         * @param {CreateStripePaymentIntentRequest} [createStripePaymentIntentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStripePaymentIntent(mintAccessToken: string, createStripePaymentIntentRequest?: CreateStripePaymentIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStripePaymentIntent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStripePaymentIntent(mintAccessToken, createStripePaymentIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get signed URL for avatar image
         * @param {string} mintAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvatar(mintAccessToken: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvatar200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvatar(mintAccessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bidded ItemStocks By WalletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {string} [onlyBeforeEnd] 
         * @param {'price' | 'endAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBiddedItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, onlyBeforeEnd?: string, sortBy?: 'price' | 'endAt', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBiddedItemStocksByWalletAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBiddedItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, onlyBeforeEnd, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get ItemStock purchased or sold at the specified walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'price' | 'createAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoughtItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, sortBy?: 'price' | 'createAt', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBoughtItemStocksByWalletAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoughtItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get ContractERC721 by  contracId
         * @param {string} mintAccessToken 
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractERC721ById(mintAccessToken: string, contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractERC721ById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractERC721ById(mintAccessToken, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Item of project by specifying Id
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemById(mintAccessToken: string, itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemById(mintAccessToken, itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get item by tokenERC721 id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemByTokenERC721(mintAccessToken: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemByTokenERC721200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemByTokenERC721(mintAccessToken, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get ItemStock by Id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemStockById(mintAccessToken: string, itemStockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemStockById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemStockById(mintAccessToken, itemStockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {GetItemStockPhysicalShippingInfoByItemStockIdRequest} [getItemStockPhysicalShippingInfoByItemStockIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken: string, itemStockId: string, getItemStockPhysicalShippingInfoByItemStockIdRequest?: GetItemStockPhysicalShippingInfoByItemStockIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemStockPhysicalShippingInfoByItemStockId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken, itemStockId, getItemStockPhysicalShippingInfoByItemStockIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info status by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken: string, itemStockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemStockPhysicalShippingInfoStatusByItemStockId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken, itemStockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the items of the project
         * @param {string} mintAccessToken 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'beforeStart' | 'beforeEnd' | 'afterEnd'} [saleStatus] 
         * @param {'true' | 'false'} [onlyAvailableStock] 
         * @param {'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price'} [paymentMethod] 
         * @param {string} [tags] Specified by the delimiter of \&#39;,\&#39;
         * @param {'price'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(mintAccessToken: string, page: string, perPage: string, saleStatus?: 'beforeStart' | 'beforeEnd' | 'afterEnd', onlyAvailableStock?: 'true' | 'false', paymentMethod?: 'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price', tags?: string, sortBy?: 'price', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(mintAccessToken, page, perPage, saleStatus, onlyAvailableStock, paymentMethod, tags, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This API is responsible to get payment intent by its id
         * @param {string} mintAccessToken 
         * @param {string} paymentIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentIntentById(mintAccessToken: string, paymentIntentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentIntentById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentIntentById(mintAccessToken, paymentIntentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get ProductERC721 which is packed in Item and the status of Item is publish
         * @param {string} mintAccessToken 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductERC721ById(mintAccessToken: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductERC721ById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductERC721ById(mintAccessToken, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there is no profile, null will be in the value of data
         * @summary Get the profile associated with the wallet
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(mintAccessToken: string, walletAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(mintAccessToken, walletAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a sellable (not yet sold) `ItemStockId` for a`Item` to sell on a Smart Contract
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSellableItemStockERC721Id(mintAccessToken: string, itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSellableItemStockERC721Id200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSellableItemStockERC721Id(mintAccessToken, itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the Sign required to operate the Smart Contract for Item purchase
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {SignatureType} signatureType 
         * @param {string} [walletAddress] Required only at the time of purchase
         * @param {'jp' | 'unknown'} [residence] Required only at the time of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignByItemStockId(mintAccessToken: string, itemStockId: string, signatureType: SignatureType, walletAddress?: string, residence?: 'jp' | 'unknown', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignByItemStockId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignByItemStockId(mintAccessToken, itemStockId, signatureType, walletAddress, residence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get TokenERC721 by Id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenERC721ById(mintAccessToken: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenERC721ById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenERC721ById(mintAccessToken, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get TokenERC721 associated with contractAddress
         * @param {string} mintAccessToken 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenERC721sByContractAddress(mintAccessToken: string, contractAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenERC721sByContractAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenERC721sByContractAddress(mintAccessToken, contractAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all TokenERC721 associated with walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenERC721sByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenERC721sByWalletAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenERC721sByWalletAddress(mintAccessToken, walletAddress, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get TokenERC721s by specifying wallet address and contract address
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokentERC721sByWalletAddressFromAnyContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken, walletAddress, contractAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary has token id of nft or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasNft(mintAccessToken: string, walletAddress: string, contractAddress: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HasNft200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasNft(mintAccessToken, walletAddress, contractAddress, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary has nfts or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasNfts(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HasNfts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasNfts(mintAccessToken, walletAddress, contractAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a profile associated with your wallet
         * @param {string} mintAccessToken 
         * @param {UpdateProfileRequest} [updateProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(mintAccessToken: string, updateProfileRequest?: UpdateProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProfile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(mintAccessToken, updateProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary API for creating or updating item stock physical shipping info for given item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {CreateOrUpdateItemStockPhysicalShippingInfoRequest} [createOrUpdateItemStockPhysicalShippingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken: string, itemStockId: string, createOrUpdateItemStockPhysicalShippingInfoRequest?: CreateOrUpdateItemStockPhysicalShippingInfoRequest, options?: any): AxiosPromise<CreateOrUpdateItemStockPhysicalShippingInfo200Response> {
            return localVarFp.createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken, itemStockId, createOrUpdateItemStockPhysicalShippingInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a PyamentIntent to purchase a given item with a credit card (Stripe) and return the corresponding Secret
         * @param {string} mintAccessToken 
         * @param {CreateStripePaymentIntentRequest} [createStripePaymentIntentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripePaymentIntent(mintAccessToken: string, createStripePaymentIntentRequest?: CreateStripePaymentIntentRequest, options?: any): AxiosPromise<CreateStripePaymentIntent200Response> {
            return localVarFp.createStripePaymentIntent(mintAccessToken, createStripePaymentIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get signed URL for avatar image
         * @param {string} mintAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar(mintAccessToken: string, options?: any): AxiosPromise<GetAvatar200Response> {
            return localVarFp.getAvatar(mintAccessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bidded ItemStocks By WalletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {string} [onlyBeforeEnd] 
         * @param {'price' | 'endAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBiddedItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, onlyBeforeEnd?: string, sortBy?: 'price' | 'endAt', sortDirection?: 'asc' | 'desc', options?: any): AxiosPromise<GetBiddedItemStocksByWalletAddress200Response> {
            return localVarFp.getBiddedItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, onlyBeforeEnd, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ItemStock purchased or sold at the specified walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'price' | 'createAt'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoughtItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, sortBy?: 'price' | 'createAt', sortDirection?: 'asc' | 'desc', options?: any): AxiosPromise<GetBoughtItemStocksByWalletAddress200Response> {
            return localVarFp.getBoughtItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ContractERC721 by  contracId
         * @param {string} mintAccessToken 
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractERC721ById(mintAccessToken: string, contractId: string, options?: any): AxiosPromise<GetContractERC721ById200Response> {
            return localVarFp.getContractERC721ById(mintAccessToken, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Item of project by specifying Id
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemById(mintAccessToken: string, itemId: string, options?: any): AxiosPromise<GetItemById200Response> {
            return localVarFp.getItemById(mintAccessToken, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get item by tokenERC721 id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByTokenERC721(mintAccessToken: string, tokenId: string, options?: any): AxiosPromise<GetItemByTokenERC721200Response> {
            return localVarFp.getItemByTokenERC721(mintAccessToken, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get ItemStock by Id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockById(mintAccessToken: string, itemStockId: string, options?: any): AxiosPromise<GetItemStockById200Response> {
            return localVarFp.getItemStockById(mintAccessToken, itemStockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {GetItemStockPhysicalShippingInfoByItemStockIdRequest} [getItemStockPhysicalShippingInfoByItemStockIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken: string, itemStockId: string, getItemStockPhysicalShippingInfoByItemStockIdRequest?: GetItemStockPhysicalShippingInfoByItemStockIdRequest, options?: any): AxiosPromise<GetItemStockPhysicalShippingInfoByItemStockId200Response> {
            return localVarFp.getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken, itemStockId, getItemStockPhysicalShippingInfoByItemStockIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary API for getting item stock physical shipping info status by item stock id
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken: string, itemStockId: string, options?: any): AxiosPromise<GetItemStockPhysicalShippingInfoStatusByItemStockId200Response> {
            return localVarFp.getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken, itemStockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the items of the project
         * @param {string} mintAccessToken 
         * @param {string} page 
         * @param {string} perPage 
         * @param {'beforeStart' | 'beforeEnd' | 'afterEnd'} [saleStatus] 
         * @param {'true' | 'false'} [onlyAvailableStock] 
         * @param {'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price'} [paymentMethod] 
         * @param {string} [tags] Specified by the delimiter of \&#39;,\&#39;
         * @param {'price'} [sortBy] 
         * @param {'asc' | 'desc'} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(mintAccessToken: string, page: string, perPage: string, saleStatus?: 'beforeStart' | 'beforeEnd' | 'afterEnd', onlyAvailableStock?: 'true' | 'false', paymentMethod?: 'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price', tags?: string, sortBy?: 'price', sortDirection?: 'asc' | 'desc', options?: any): AxiosPromise<GetItems200Response> {
            return localVarFp.getItems(mintAccessToken, page, perPage, saleStatus, onlyAvailableStock, paymentMethod, tags, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This API is responsible to get payment intent by its id
         * @param {string} mintAccessToken 
         * @param {string} paymentIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntentById(mintAccessToken: string, paymentIntentId: string, options?: any): AxiosPromise<GetPaymentIntentById200Response> {
            return localVarFp.getPaymentIntentById(mintAccessToken, paymentIntentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ProductERC721 which is packed in Item and the status of Item is publish
         * @param {string} mintAccessToken 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductERC721ById(mintAccessToken: string, id: string, options?: any): AxiosPromise<GetProductERC721ById200Response> {
            return localVarFp.getProductERC721ById(mintAccessToken, id, options).then((request) => request(axios, basePath));
        },
        /**
         * If there is no profile, null will be in the value of data
         * @summary Get the profile associated with the wallet
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(mintAccessToken: string, walletAddress: string, options?: any): AxiosPromise<GetProfile200Response> {
            return localVarFp.getProfile(mintAccessToken, walletAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a sellable (not yet sold) `ItemStockId` for a`Item` to sell on a Smart Contract
         * @param {string} mintAccessToken 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellableItemStockERC721Id(mintAccessToken: string, itemId: string, options?: any): AxiosPromise<GetSellableItemStockERC721Id200Response> {
            return localVarFp.getSellableItemStockERC721Id(mintAccessToken, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the Sign required to operate the Smart Contract for Item purchase
         * @param {string} mintAccessToken 
         * @param {string} itemStockId 
         * @param {SignatureType} signatureType 
         * @param {string} [walletAddress] Required only at the time of purchase
         * @param {'jp' | 'unknown'} [residence] Required only at the time of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignByItemStockId(mintAccessToken: string, itemStockId: string, signatureType: SignatureType, walletAddress?: string, residence?: 'jp' | 'unknown', options?: any): AxiosPromise<GetSignByItemStockId200Response> {
            return localVarFp.getSignByItemStockId(mintAccessToken, itemStockId, signatureType, walletAddress, residence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get TokenERC721 by Id
         * @param {string} mintAccessToken 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721ById(mintAccessToken: string, tokenId: string, options?: any): AxiosPromise<GetTokenERC721ById200Response> {
            return localVarFp.getTokenERC721ById(mintAccessToken, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TokenERC721 associated with contractAddress
         * @param {string} mintAccessToken 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721sByContractAddress(mintAccessToken: string, contractAddress: string, options?: any): AxiosPromise<GetTokenERC721sByContractAddress200Response> {
            return localVarFp.getTokenERC721sByContractAddress(mintAccessToken, contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all TokenERC721 associated with walletAddress
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} page 
         * @param {string} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenERC721sByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, options?: any): AxiosPromise<GetTokenERC721sByWalletAddress200Response> {
            return localVarFp.getTokenERC721sByWalletAddress(mintAccessToken, walletAddress, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get TokenERC721s by specifying wallet address and contract address
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: any): AxiosPromise<GetTokentERC721sByWalletAddressFromAnyContract200Response> {
            return localVarFp.getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken, walletAddress, contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary has token id of nft or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasNft(mintAccessToken: string, walletAddress: string, contractAddress: string, tokenId: string, options?: any): AxiosPromise<HasNft200Response> {
            return localVarFp.hasNft(mintAccessToken, walletAddress, contractAddress, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary has nfts or not in contract
         * @param {string} mintAccessToken 
         * @param {string} walletAddress 
         * @param {string} contractAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasNfts(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: any): AxiosPromise<HasNfts200Response> {
            return localVarFp.hasNfts(mintAccessToken, walletAddress, contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a profile associated with your wallet
         * @param {string} mintAccessToken 
         * @param {UpdateProfileRequest} [updateProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(mintAccessToken: string, updateProfileRequest?: UpdateProfileRequest, options?: any): AxiosPromise<UpdateProfile200Response> {
            return localVarFp.updateProfile(mintAccessToken, updateProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary API for creating or updating item stock physical shipping info for given item stock id
     * @param {string} mintAccessToken 
     * @param {string} itemStockId 
     * @param {CreateOrUpdateItemStockPhysicalShippingInfoRequest} [createOrUpdateItemStockPhysicalShippingInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken: string, itemStockId: string, createOrUpdateItemStockPhysicalShippingInfoRequest?: CreateOrUpdateItemStockPhysicalShippingInfoRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createOrUpdateItemStockPhysicalShippingInfo(mintAccessToken, itemStockId, createOrUpdateItemStockPhysicalShippingInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a PyamentIntent to purchase a given item with a credit card (Stripe) and return the corresponding Secret
     * @param {string} mintAccessToken 
     * @param {CreateStripePaymentIntentRequest} [createStripePaymentIntentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createStripePaymentIntent(mintAccessToken: string, createStripePaymentIntentRequest?: CreateStripePaymentIntentRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createStripePaymentIntent(mintAccessToken, createStripePaymentIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get signed URL for avatar image
     * @param {string} mintAccessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAvatar(mintAccessToken: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAvatar(mintAccessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bidded ItemStocks By WalletAddress
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} page 
     * @param {string} perPage 
     * @param {string} [onlyBeforeEnd] 
     * @param {'price' | 'endAt'} [sortBy] 
     * @param {'asc' | 'desc'} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBiddedItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, onlyBeforeEnd?: string, sortBy?: 'price' | 'endAt', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBiddedItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, onlyBeforeEnd, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ItemStock purchased or sold at the specified walletAddress
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} page 
     * @param {string} perPage 
     * @param {'price' | 'createAt'} [sortBy] 
     * @param {'asc' | 'desc'} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBoughtItemStocksByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, sortBy?: 'price' | 'createAt', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBoughtItemStocksByWalletAddress(mintAccessToken, walletAddress, page, perPage, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ContractERC721 by  contracId
     * @param {string} mintAccessToken 
     * @param {string} contractId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractERC721ById(mintAccessToken: string, contractId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractERC721ById(mintAccessToken, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Item of project by specifying Id
     * @param {string} mintAccessToken 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItemById(mintAccessToken: string, itemId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItemById(mintAccessToken, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get item by tokenERC721 id
     * @param {string} mintAccessToken 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItemByTokenERC721(mintAccessToken: string, tokenId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItemByTokenERC721(mintAccessToken, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get ItemStock by Id
     * @param {string} mintAccessToken 
     * @param {string} itemStockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItemStockById(mintAccessToken: string, itemStockId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItemStockById(mintAccessToken, itemStockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary API for getting item stock physical shipping info by item stock id
     * @param {string} mintAccessToken 
     * @param {string} itemStockId 
     * @param {GetItemStockPhysicalShippingInfoByItemStockIdRequest} [getItemStockPhysicalShippingInfoByItemStockIdRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken: string, itemStockId: string, getItemStockPhysicalShippingInfoByItemStockIdRequest?: GetItemStockPhysicalShippingInfoByItemStockIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItemStockPhysicalShippingInfoByItemStockId(mintAccessToken, itemStockId, getItemStockPhysicalShippingInfoByItemStockIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary API for getting item stock physical shipping info status by item stock id
     * @param {string} mintAccessToken 
     * @param {string} itemStockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken: string, itemStockId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItemStockPhysicalShippingInfoStatusByItemStockId(mintAccessToken, itemStockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the items of the project
     * @param {string} mintAccessToken 
     * @param {string} page 
     * @param {string} perPage 
     * @param {'beforeStart' | 'beforeEnd' | 'afterEnd'} [saleStatus] 
     * @param {'true' | 'false'} [onlyAvailableStock] 
     * @param {'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price'} [paymentMethod] 
     * @param {string} [tags] Specified by the delimiter of \&#39;,\&#39;
     * @param {'price'} [sortBy] 
     * @param {'asc' | 'desc'} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getItems(mintAccessToken: string, page: string, perPage: string, saleStatus?: 'beforeStart' | 'beforeEnd' | 'afterEnd', onlyAvailableStock?: 'true' | 'false', paymentMethod?: 'ethereum-contract-erc721-shop-fixed-price' | 'ethereum-contract-erc721-shop-auction' | 'credit-card-stripe-fixed-price', tags?: string, sortBy?: 'price', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getItems(mintAccessToken, page, perPage, saleStatus, onlyAvailableStock, paymentMethod, tags, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This API is responsible to get payment intent by its id
     * @param {string} mintAccessToken 
     * @param {string} paymentIntentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPaymentIntentById(mintAccessToken: string, paymentIntentId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPaymentIntentById(mintAccessToken, paymentIntentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ProductERC721 which is packed in Item and the status of Item is publish
     * @param {string} mintAccessToken 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductERC721ById(mintAccessToken: string, id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProductERC721ById(mintAccessToken, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there is no profile, null will be in the value of data
     * @summary Get the profile associated with the wallet
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProfile(mintAccessToken: string, walletAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProfile(mintAccessToken, walletAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a sellable (not yet sold) `ItemStockId` for a`Item` to sell on a Smart Contract
     * @param {string} mintAccessToken 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSellableItemStockERC721Id(mintAccessToken: string, itemId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSellableItemStockERC721Id(mintAccessToken, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the Sign required to operate the Smart Contract for Item purchase
     * @param {string} mintAccessToken 
     * @param {string} itemStockId 
     * @param {SignatureType} signatureType 
     * @param {string} [walletAddress] Required only at the time of purchase
     * @param {'jp' | 'unknown'} [residence] Required only at the time of purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSignByItemStockId(mintAccessToken: string, itemStockId: string, signatureType: SignatureType, walletAddress?: string, residence?: 'jp' | 'unknown', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSignByItemStockId(mintAccessToken, itemStockId, signatureType, walletAddress, residence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get TokenERC721 by Id
     * @param {string} mintAccessToken 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenERC721ById(mintAccessToken: string, tokenId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenERC721ById(mintAccessToken, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TokenERC721 associated with contractAddress
     * @param {string} mintAccessToken 
     * @param {string} contractAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenERC721sByContractAddress(mintAccessToken: string, contractAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenERC721sByContractAddress(mintAccessToken, contractAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all TokenERC721 associated with walletAddress
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} page 
     * @param {string} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenERC721sByWalletAddress(mintAccessToken: string, walletAddress: string, page: string, perPage: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenERC721sByWalletAddress(mintAccessToken, walletAddress, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get TokenERC721s by specifying wallet address and contract address
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} contractAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokentERC721sByWalletAddressFromAnyContract(mintAccessToken, walletAddress, contractAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary has token id of nft or not in contract
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} contractAddress 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hasNft(mintAccessToken: string, walletAddress: string, contractAddress: string, tokenId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hasNft(mintAccessToken, walletAddress, contractAddress, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary has nfts or not in contract
     * @param {string} mintAccessToken 
     * @param {string} walletAddress 
     * @param {string} contractAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hasNfts(mintAccessToken: string, walletAddress: string, contractAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hasNfts(mintAccessToken, walletAddress, contractAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a profile associated with your wallet
     * @param {string} mintAccessToken 
     * @param {UpdateProfileRequest} [updateProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProfile(mintAccessToken: string, updateProfileRequest?: UpdateProfileRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProfile(mintAccessToken, updateProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


